(window.webpackJsonp=window.webpackJsonp||[]).push([[109],{482:function(a,t,s){"use strict";s.r(t);var r=s(8),v=Object(r.a)({},(function(){var a=this,t=a._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[t("h1",{attrs:{id:"服务架构设计"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#服务架构设计"}},[a._v("#")]),a._v(" 服务架构设计")]),a._v(" "),t("h2",{attrs:{id:"概述"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#概述"}},[a._v("#")]),a._v(" 概述")]),a._v(" "),t("p",[a._v("服务化是一种方法，它开发一个单一的应用程序来作为构成整体服务的小服务，每个小服务都运行在它自己的进程中，\n并且使用一个轻量级的机制进行通讯。这些服务都围绕业务能力来构建，并且可依赖全自动部署机制来独立部署。这在一定\n程度上解决了伸缩性问题、运行效率问题、开发效率问题，并支持在纵向和横向两个维度进行伸缩，促进新旧技术和架构的更替。")]),a._v(" "),t("h2",{attrs:{id:"服务架构设计-2"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#服务架构设计-2"}},[a._v("#")]),a._v(" 服务架构设计")]),a._v(" "),t("img",{attrs:{src:a.$withBase("/framework/07_service.png")}}),a._v(" "),t("h2",{attrs:{id:"服务架构思想"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#服务架构思想"}},[a._v("#")]),a._v(" 服务架构思想")]),a._v(" "),t("blockquote",[t("p",[a._v("研发平台架构设计思想极度参考的基础六大架构设计原则")])]),a._v(" "),t("h3",{attrs:{id:"单一职责原则"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#单一职责原则"}},[a._v("#")]),a._v(" 单一职责原则")]),a._v(" "),t("p",[a._v("对于一个类而言，应该仅有一个引起它变化的原因。说白了就是，不同的类具备不同的职责，各施其责。这就好比一个团队，大家分工协作，互不影响，各做各的事情。")]),a._v(" "),t("h3",{attrs:{id:"开放封闭原则"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#开放封闭原则"}},[a._v("#")]),a._v(" 开放封闭原则")]),a._v(" "),t("p",[a._v("简言之，对扩展开放，对修改封闭。换句话说，可以去扩展类，但不要去修改类。")]),a._v(" "),t("h3",{attrs:{id:"里氏替换原则"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#里氏替换原则"}},[a._v("#")]),a._v(" 里氏替换原则")]),a._v(" "),t("p",[a._v("父类能够替换子类，但子类不一定能替换父类。也就是说，在代码中可以将父类全部替换为子类，程序不会报错，也不会在运行时出现任何异常，但反过来却不一定成立。")]),a._v(" "),t("h3",{attrs:{id:"最少知识原则"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#最少知识原则"}},[a._v("#")]),a._v(" 最少知识原则")]),a._v(" "),t("p",[a._v("尽量减少对象之间的交互，从而减小类之间的耦合。简言之，一定要做到：低耦合，高内聚。")]),a._v(" "),t("h3",{attrs:{id:"接口隔离原则"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#接口隔离原则"}},[a._v("#")]),a._v(" 接口隔离原则")]),a._v(" "),t("p",[a._v("不要对外暴露没有实际意义的接口。也就是说，接口是给别人调用的，那就不要去为难别人了，尽可能保证接口的实用性吧。她好，我也好。")]),a._v(" "),t("h3",{attrs:{id:"依赖倒置原则"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#依赖倒置原则"}},[a._v("#")]),a._v(" 依赖倒置原则")]),a._v(" "),t("p",[a._v("应该面向接口编程，不应该面向实现类编程。面向实现类编程，相当于就是论事，那是正向依赖（正常人思维）；面向接口编程，相当于通过事物表象来看本质，那是反向依赖，即依赖倒置（程序员思维）。")]),a._v(" "),t("h1",{attrs:{id:"架构说明"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#架构说明"}},[a._v("#")]),a._v(" 架构说明")]),a._v(" "),t("h3",{attrs:{id:"强约束性"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#强约束性"}},[a._v("#")]),a._v(" 强约束性")]),a._v(" "),t("p",[a._v("平台提供基础环境和配置，第三方接口封装，对开发只能对接口可见，比如短信，开发只能对接口，\n不需要考虑哪个运营商或者哪个平台的短信。")]),a._v(" "),t("h3",{attrs:{id:"技术透明化"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#技术透明化"}},[a._v("#")]),a._v(" 技术透明化")]),a._v(" "),t("p",[a._v("平台针对前端,后台,部署都做了进行统一化管理，研发人员只针对业务需求进行开发，只关注业务")]),a._v(" "),t("h3",{attrs:{id:"技术简化性"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#技术简化性"}},[a._v("#")]),a._v(" 技术简化性")]),a._v(" "),t("p",[a._v("平台针对于技术尽量减少简化，开发技术在适度范围内禁止添加，如版本，只能使用 jdk 某版本，\n前端减去复杂性，如去掉 node，以简洁为主。")]),a._v(" "),t("h2",{attrs:{id:"其它"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#其它"}},[a._v("#")]),a._v(" 其它")]),a._v(" "),t("ul",[t("li",[a._v("略")])])])}),[],!1,null,null,null);t.default=v.exports}}]);